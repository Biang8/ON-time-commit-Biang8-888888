name: Old WeChat

# 定义工作流的触发条件
on:
  # 定时任务触发条件
  schedule:
    # 晚间任务：北京时间每天 22:00 触发，转换为 UTC 时间是 14:00
    - cron: '0 14 * * *'          # 北京时间：22:00，UTC 时间：14:00
    # 早间任务：北京时间周一到周五 05:00 触发，转换为 UTC 时间是前一天的 21:00
    - cron: '0 21 * * 0-4'        # 北京时间：05:00（周一到周五），UTC 时间：21:00（周日到周四）
    # 午间任务：北京时间周一到周五 11:40 触发，转换为 UTC 时间是 03:40
    - cron: '40 3 * * 1-5'        # 北京时间：11:40（周一到周五），UTC 时间：03:40（周一到周五）
    # 周末任务：北京时间周六和周日 17:00 触发，转换为 UTC 时间是 09:00
    - cron: '0 9 * * sat,sun'     # 北京时间：17:00（周六和周日），UTC 时间：09:00（周六和周日）
    # 周随机任务：北京时间周末 08:00 触发，转换为 UTC 时间是前一天的 00:00
    - cron: '0 0 * * sat,sun'     # 北京时间：08:00（周六和周日），UTC 时间：00:00（周五和周六）
  # 手动触发条件
  workflow_dispatch:  
    description: 手动触发微信阅读任务
    inputs:
      mode:
        type: choice
        description: |
          选择运行模式：
          - 自动：自动模式，根据不同的定时任务规则，生成相应范围内的随机阅读时间。如果是手动触发且未设置自定义延迟，会有 0 - 20 分钟的随机延迟。
          - 手动：手动模式，若未输入自定义阅读时间，会生成 60 - 120（等效 30 - 60 分钟）之间的随机阅读时间；若输入了自定义阅读时间，则使用该时间计算阅读次数。
        required: true
        default: '手动'
        options:
          - 自动
          - 手动
      custom_time:
        type: string
        description: '手动输入自定义阅读时间（分钟，仅手动触发有效）。输入后，会将该时间乘以 2 作为 READ_NUM 用于后续任务。'
        required: false
      custom_delay:
        type: string
        description: '手动输入自定义延迟时间（分钟，仅手动触发有效）。输入后，任务会延迟相应的分钟数执行。'
        required: false
      debug_schedule:  
        type: choice
        description: '选择调试定时任务，开启后按指定任务时间运行'
        required: false
        default: '无'
        options:
          - 无
          - 晚间任务
          - 早间任务
          - 午间任务
          - 周末任务
          - 周随机任务

jobs:
  deploy:
    runs-on: ubuntu-22.04
    environment: AutoRead
    outputs:
      week_random_skipped: ${{ steps.week_random_check.outputs.skipped }}

    steps:
    - name: 🔧 设置 DNS  
      run: |
        # 配置主 DNS 服务器为 Google 的公共 DNS
        echo "nameserver 8.8.8.8" | sudo tee /etc/resolv.conf
        # 配置备用 DNS 服务器为 Google 的公共 DNS
        echo "nameserver 8.8.4.4" | sudo tee -a /etc/resolv.conf
        echo "✅ DNS 配置完成"

    - name: 📥 检出仓库
      uses: actions/checkout@v4

    - name: 🐍 设置 Python 3.10
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: 📦 安装依赖
      run: |
        echo "::group::📦 安装依赖"
        python -m pip install --upgrade pip
        pip install --no-cache-dir -r requirements.txt
        pip list  # 显示安装的依赖
        echo "::endgroup::"
        # 验证 requests 库是否安装成功
        echo "✅ 依赖安装验证：$(pip list | grep requests)"

    - name: ⏱️ 调试任务延迟（手动触发且选择调试任务）
      if: github.event_name == 'workflow_dispatch' && github.event.inputs.debug_schedule != '无'
      run: |
        case "${{ github.event.inputs.debug_schedule }}" in
          晚间任务)
            SCHEDULE='0 14 * * *'
            ;;
          早间任务)
            SCHEDULE='0 21 * * 0-4'
            ;;
          午间任务)
            SCHEDULE='40 3 * * 1-5'
            ;;
          周末任务)
            SCHEDULE='0 9 * * sat,sun'
            ;;
          周随机任务)
            SCHEDULE='0 0 * * sat,sun'
            ;;
        esac
        # 计算当前时间到预定时间的延迟
        CURRENT_TIME=$(date +"%M %H %d %m %w")
        IFS=' ' read -r MINUTE HOUR DAY MONTH WEEKDAY <<< "$CURRENT_TIME"
        # 打印原始的 SCHEDULE 变量
        echo "原始 SCHEDULE: $SCHEDULE"
        # 明确指定 IFS 为空格
        IFS=' '
        CLEANED_SCHEDULE=$(echo $SCHEDULE | sed 's/*/0/g' | sed 's/sat/6/g' | sed 's/sun/0/g' | cut -d' ' -f1-5)
        # 打印清理后的 SCHEDULE 变量
        echo "清理后的 SCHEDULE: $CLEANED_SCHEDULE"
        IFS=' ' read -r CRON_MINUTE CRON_HOUR CRON_DAY CRON_MONTH CRON_WEEKDAY <<< "$CLEANED_SCHEDULE"

        # 打印解析后的变量
        echo "解析后的 CRON_MINUTE: $CRON_MINUTE"
        echo "解析后的 CRON_HOUR: $CRON_HOUR"
        echo "解析后的 CRON_DAY: $CRON_DAY"
        echo "解析后的 CRON_MONTH: $CRON_MONTH"
        echo "解析后的 CRON_WEEKDAY: $CRON_WEEKDAY"

        # 检查解析后的变量是否为数字
        if ! [[ $CRON_MINUTE =~ ^[0-9]+$ ]] || ! [[ $CRON_HOUR =~ ^[0-9]+$ ]] || ! [[ $CRON_DAY =~ ^[0-9]+$ ]] || ! [[ $CRON_MONTH =~ ^[0-9]+$ ]] || ! [[ $CRON_WEEKDAY =~ ^[0-9]+$ ]]; then
            echo "Error: 解析后的日期变量包含非数字字符"
            exit 1
        fi

        # 打印调试信息
        echo "CURRENT: MONTH=$MONTH, DAY=$DAY, HOUR=$HOUR, MINUTE=$MINUTE"
        echo "SCHEDULED: CRON_MONTH=$CRON_MONTH, CRON_DAY=$CRON_DAY, CRON_HOUR=$CRON_HOUR, CRON_MINUTE=$CRON_MINUTE"

        # 计算延迟时间，考虑日期跨天
        CURRENT_TIMESTAMP=$(date -d "$MONTH/$DAY/$((1900 + $(date +%y))) $HOUR:$MINUTE" +%s 2>/dev/null)
        if [ $? -ne 0 ]; then
            echo "Error: Failed to parse current date: $MONTH/$DAY/$((1900 + $(date +%y))) $HOUR:$MINUTE"
            exit 1
        fi

        SCHEDULED_TIMESTAMP=$(date -d "$CRON_MONTH/$CRON_DAY/$((1900 + $(date +%y))) $CRON_HOUR:$CRON_MINUTE" +%s 2>/dev/null)
        if [ $? -ne 0 ]; then
            echo "Error: Failed to parse scheduled date: $CRON_MONTH/$CRON_DAY/$((1900 + $(date +%y))) $CRON_HOUR:$CRON_MINUTE"
            exit 1
        fi

        if [ $SCHEDULED_TIMESTAMP -lt $CURRENT_TIMESTAMP ]; then
          SCHEDULED_TIMESTAMP=$((SCHEDULED_TIMESTAMP + 86400)) # 加一天
        fi

        DELAY_SECONDS=$((SCHEDULED_TIMESTAMP - CURRENT_TIMESTAMP))
        DELAY_MINUTES=$((DELAY_SECONDS / 60))

        echo "⏳ 调试任务延迟：${DELAY_MINUTES} 分钟"
        sleep $DELAY_MINUTES  
        
    - name: 🎲 周随机检查
      id: week_random_check
      if: (github.event_name == 'schedule' && github.event.schedule == '0 0 * * sat,sun') || (github.event_name == 'workflow_dispatch' && github.event.inputs.debug_schedule == '周随机任务')
      run: |
        # 生成 0 到 6 之间的随机数
        CHECK=$((RANDOM % 7))
        echo "🎲 随机数：$CHECK (需要等于0)"
        # 如果随机数不等于 0，则跳过周随机任务
        if [ $CHECK -ne 0 ]; then
          echo "⏭️ 跳过周随机任务"
          echo "skipped=true" >> $GITHUB_OUTPUT
          exit 0
        else
          echo "🎉 触发周随机任务"
          echo "skipped=false" >> $GITHUB_OUTPUT
        fi

    - name: 🔢 生成 READ_NUM
      if: steps.week_random_check.outputs.skipped != 'true'
      run: |
        echo "::group::🔢 生成 READ_NUM"
        echo "=== 触发事件分析 ==="
        echo "事件类型: ${{ github.event_name }}"
        echo "输入模式: ${{ github.event.inputs.mode }}"
        echo "定时规则: ${{ github.event.schedule }}"
        echo "自定义时间: ${{ github.event.inputs.custom_time }}"
        echo "自定义延迟: ${{ github.event.inputs.custom_delay }}"
        echo "调试定时任务: ${{ github.event.inputs.debug_schedule }}"

        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          if [[ "${{ github.event.inputs.debug_schedule }}" != "无" ]]; then
            case "${{ github.event.inputs.debug_schedule }}" in
              晚间任务)
                SCHEDULE='0 14 * * *'
                ;;
              早间任务)
                SCHEDULE='0 21 * * 0-4'
                ;;
              午间任务)
                SCHEDULE='40 3 * * 1-5'
                ;;
              周末任务)
                SCHEDULE='0 9 * * sat,sun'
                ;;
              周随机任务)
                SCHEDULE='0 0 * * sat,sun'
                ;;
            esac
          else
            SCHEDULE="${{ github.event.schedule }}"
          fi

          # 手动触发时，使用自定义时间（如果存在）
          if [[ -n "${{ github.event.inputs.custom_time }}" ]]; then
            # 若用户手动输入了自定义阅读时间，则将其乘以 2 作为 READ_NUM
            NUM=$(( ${{ github.event.inputs.custom_time }} * 2 ))
            echo "🕹️ 手动触发 | 使用自定义时间: ${{ github.event.inputs.custom_time }} 分钟，等效 READ_NUM: $NUM"
          else
            # 手动触发但未提供自定义时间时，根据 mode 生成默认值
            if [[ "${{ github.event.inputs.mode }}" == "手动" ]]; then
              # 手动模式下，生成 60 到 120 之间的随机数作为 READ_NUM
              # 该范围等效于 30 到 60 分钟的阅读时间
              NUM=$((RANDOM % 61 + 60))
              echo "🕹️ 手动模式 | 范围: 60-120 (30-60分钟)"
            else
              # 手动触发 自动 模式时，使用默认的 自动 范围
              case "$SCHEDULE" in
                '0 21 * * 0-4')
                  # 早间任务（周一到周五 05:00 触发），生成 130 到 160 之间的随机数作为 READ_NUM
                  NUM=$((RANDOM % 31 + 130))
                  echo "🌅 早间任务 | 范围: 130-160"
                  ;;
                '40 3 * * 1-5')
                  # 午间任务（周一到周五 11:40 触发），生成 160 到 190 之间的随机数作为 READ_NUM
                  NUM=$((RANDOM % 31 + 160))
                  echo "🌞 午间任务 | 范围: 160-190"
                  ;;
                '0 14 * * *')
                  # 晚间任务（每天 22:00 触发），生成 190 到 220 之间的随机数作为 READ_NUM
                  NUM=$((RANDOM % 31 + 190))
                  echo "🌙 晚间任务 | 范围: 190-220"
                  ;;
                '0 9 * * sat,sun')
                  # 周末任务（周六和周日 17:00 触发），生成 190 到 220 之间的随机数作为 READ_NUM
                  NUM=$((RANDOM % 31 + 190))
                  echo "🎉 周末任务 | 范围: 190-220"
                  ;;
                '0 0 * * sat,sun')
                  # 周随机任务（周末 08:00 触发），生成 120 到 180 之间的随机数作为 READ_NUM
                  NUM=$((RANDOM % 61 + 120))
                  echo "🎰 周随机任务 | 范围: 120-180"
                  ;;
                *)
                  # 未知触发类型，启用安全默认值，生成 190 到 220 之间的随机数作为 READ_NUM
                  NUM=$((RANDOM % 31 + 190))
                  echo "⚠️ 未知触发类型 | 启用安全默认值: 190-220"
                  ;;
              esac
            fi
          fi
        else
          # 自动触发（schedule）时，按原逻辑生成
          SCHEDULE="${{ github.event.schedule }}"
          case "$SCHEDULE" in
            '0 21 * * 0-4')
              # 早间任务（周一到周五 05:00 触发），生成 130 到 160 之间的随机数作为 READ_NUM
              NUM=$((RANDOM % 31 + 130))
              echo "🌅 早间任务 | 范围: 130-160"
              ;;
            '40 3 * * 1-5')
              # 午间任务（周一到周五 11:40 触发），生成 160 到 190 之间的随机数作为 READ_NUM
              NUM=$((RANDOM % 31 + 160))
              echo "🌞 午间任务 | 范围: 160-190"
              ;;
            '0 14 * * *')
              # 晚间任务（每天 22:00 触发），生成 190 到 220 之间的随机数作为 READ_NUM
              NUM=$((RANDOM % 31 + 190))
              echo "🌙 晚间任务 | 范围: 190-220"
              ;;
            '0 9 * * sat,sun')
              # 周末任务（周六和周日 17:00 触发），生成 190 到 220 之间的随机数作为 READ_NUM
              NUM=$((RANDOM % 31 + 190))
              echo "🎉 周末任务 | 范围: 190-220"
              ;;
            '0 0 * * sat,sun')
              # 周随机任务（周末 08:00 触发），生成 120 到 180 之间的随机数作为 READ_NUM
              NUM=$((RANDOM % 61 + 120))
              echo "🎰 周随机任务 | 范围: 120-180"
              ;;
            *)
              # 未知触发类型，启用安全默认值，生成 190 到 220 之间的随机数作为 READ_NUM
              NUM=$((RANDOM % 31 + 190))
              echo "⚠️ 未知触发类型 | 启用安全默认值: 190-220"
              ;;
          esac
        fi

        echo "✅ 最终 READ_NUM: $NUM (等效 $((NUM / 2)) 分钟)"
        # 将 READ_NUM 写入环境变量
        echo "READ_NUM=$NUM" >> $GITHUB_ENV
        echo "::endgroup::"

    - name: 🚀 执行主程序
      if: steps.week_random_check.outputs.skipped != 'true'
      env:
        WXREAD_CURL_BASH: ${{ secrets.WXREAD_CURL_BASH }}
        PUSH_METHOD: ${{ secrets.PUSH_METHOD }}
        PUSHPLUS_TOKEN: ${{ secrets.PUSHPLUS_TOKEN }}
        WXPUSHER_SPT: ${{ secrets.WXPUSHER_SPT }}
        TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        READ_NUM: ${{ env.READ_NUM }}
        READ_COMPLETE_HEADER: ${{ secrets.READ_COMPLETE_HEADER }}  # 读取 GitHub Secrets 里的变量
      run: |
        echo "=== 执行参数 ==="
        echo "READ_NUM: ${{ env.READ_NUM }}"
        echo "READ_COMPLETE_HEADER: ${{ env.READ_COMPLETE_HEADER }}"
        # 执行主程序
        python main.py || { echo "❌ 主程序执行失败"; exit 1; }
